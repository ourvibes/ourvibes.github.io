import{_ as i,c as s,o as a,a1 as l}from"./chunks/framework.wqF_p4e1.js";const g=JSON.parse('{"title":"Q&A - project","description":"","frontmatter":{"title":"Q&A - project"},"headers":[],"relativePath":"flow/fe/iq-project.md","filePath":"flow/fe/iq-project.md"}'),p={name:"flow/fe/iq-project.md"},n=l(`<div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> production</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> webpack</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -v</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> update</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://registry.npm.taobao.org</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registery</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cnpm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --registry=https://registry.npm.taobao.org</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cnpm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -v</span></span></code></pre></div><hr><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inBrowser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;undefined&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inBrowser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.navigator.userAgent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isIE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">msie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">trident</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isIE9</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;msie 9.0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isEdge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;edge/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isAndroid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;android&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isIOS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">iphone</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">ipad</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">ipod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">ios</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isChrome</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">chrome</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isEdge</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isFF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">firefox</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> G</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><details class="details custom-block"><summary>什么是MVVM?</summary><p>MVVM（Model-View-ViewModel）是一种软件架构<code>设计模式</code>，就是定义了一个<code>Observer</code>观察者。ViewModel 是连接 View 和 Model 的桥梁。</p><ul><li>ViewModel能够观察到数据的变化，并对视图对应的内容进行更新。</li><li>ViewModel能够监听到视图的变化，并能够通知数据发生变化。</li></ul></details><details class="details custom-block"><summary>白屏性能优化 ？</summary><p>前端白屏性能优化是前端开发中的重要一环，它涉及到多个方面，包括代码优化、资源加载优化、渲染优化等。以下是一些建议和实践，可以帮助你优化前端白屏问题：</p><ul><li><p>代码拆分和懒加载：</p><ul><li>使用<code>代码拆分</code>（code splitting）将大型代码库拆分为较小的块，这样用户只加载他们当前需要的部分。</li><li><code>懒加载</code>（lazy loading）可以延迟加载非关键资源，直到它们真正需要时才加载。</li></ul></li><li><p>优化资源加载：</p><ul><li><code>压缩</code>图片、CSS和JavaScript文件，减少传输时间。</li><li>使用<code>CDN</code>（内容分发网络）加速资源加载。</li><li>利用<code> HTTP 缓存机制</code>，避免重复加载未变更的资源。</li></ul></li><li><p>使用预渲染或服务端渲染：</p><ul><li><code>预渲染</code>可以生成静态HTML文件，减少页面首次加载时的渲染时间。</li><li><code>服务端渲染</code>（SSR）将渲染过程放在服务器端执行，然后将渲染好的HTML发送给客户端，可以加快首屏渲染速度。</li></ul></li><li><p>优化JavaScript执行：</p><ul><li>尽量减少JavaScript代码量，避免阻塞渲染。</li><li>使用<code>async</code>和<code>defer</code>属性异步加载脚本。</li><li>利用<code>Web Workers</code>进行后台线程处理，避免阻塞主线程。</li></ul></li><li><p>使用骨架屏或占位符：</p><ul><li>在内容加载完成之前，使用<code>骨架屏</code>或占位符展示页面结构，减少用户等待时的白屏时间。</li></ul></li><li><p>利用浏览器缓存：</p><ul><li>合理使用<code>浏览器的缓存机制</code>，如localStorage、sessionStorage或IndexedDB等，缓存已加载过的资源或数据。</li></ul></li><li><p>减少DOM操作：</p><ul><li>尽量<code>减少不必要的DOM操作</code>，尤其是大量或频繁的DOM操作，因为它们可能导致页面重绘或重排，影响性能。</li></ul></li><li><p>利用CSS优化：</p><ul><li>使用<code>CSS3动画</code>代替JavaScript动画，减少渲染阻塞。</li><li>避免使用复杂的CSS选择器，提高选择器的性能。</li></ul></li><li><p>使用性能分析工具：</p><ul><li>使用Lighthouse、<code>Chrome DevTools</code>等性能分析工具，分析页面加载和渲染过程中的瓶颈，并针对性地进行优化。</li></ul></li><li><p>持续监控和优化：</p><ul><li>监控用户设备的性能数据，了解不同设备下的性能表现，并根据需要进行优化。</li><li>定期对网站进行<code>性能测试</code>和优化，确保性能持续稳定。</li></ul></li></ul></details><details class="details custom-block"><summary>SSR是什么？</summary><p>SSR（Server-Side Rendering，<code>服务器端渲染</code>）是一种将应用程序的界面在服务器上进行预先渲染并以 HTML 形式发送到客户端的技术。与传统的客户端渲染（CSR）相比，SSR 在服务器端生成完整的 HTML 页面，然后将其发送到浏览器，以提供更好的性能和搜索引擎优化。</p><p>优势：</p><ul><li><code>更快的首次渲染</code>：由于服务器在响应请求时已经生成了完整的 HTML 页面，所以用户打开页面时可以立即看到内容，无需等待 JavaScript 下载和执行。</li><li><code>更好的搜索引擎优化（SEO）</code>：搜索引擎爬虫能够抓取到完整的 HTML 页面，并且页面内容可直接被搜索引擎索引。</li><li><code>更好的用户体验</code>：页面内容在服务器端渲染完成后即可展示，减少了白屏时间和加载等待。</li></ul></details><details class="details custom-block"><summary>说下 Vite 的原理</summary><p>共存的模块化标准:</p><ul><li>CommonJS：现主要用于Node.js（Node@13.2.0开始支持直接使用ES Module）</li><li>AMD：require.js 依赖前置</li><li>CMD：sea.js 就近执行</li><li>ES Module：ES语言规范</li></ul><p>当前工程化的痛点：</p><ul><li>缓慢的服务启动</li><li>缓慢的HMR热更新</li></ul><p>Vite：基于 <code>esbuild</code> 与 <code>Rollup</code>，依靠浏览器自身 <code>ESM</code> 编译功能， 实现极致开发体验的新一代构建工具！</p><ul><li>依赖： 指开发不会变动的部分(npm包、UI组件库)，esbuild进行预构建。</li><li>源码： 浏览器不能直接执行的非 js 代码(.jsx、.css、.vue等)，vite只在浏览器请求相关源码的时候进行转换，以提供ESM源码。</li></ul><p>实现原理：</p><ul><li><p>ESbuild 编译</p><ul><li>esbuild 使用 go 编写，cpu 密集下更具性能优势，编译速度更快</li></ul></li><li><p>依赖预构建</p><ul><li>模块化兼容： 如开头背景所写，现仍共存多种模块化标准代码，Vite 在预构建阶段将依赖中各种其他模块化规范(CommonJS、UMD)转换成 <code>ESM</code>，以提供给浏览器。</li><li>性能优化： npm 包中大量的 ESM 代码，大量的 import 请求，会造成网络拥塞。Vite 使用 esbuild，将有大量内部模块的 ESM 关系转换成单个模块，以<code>减少 import 模块请求次数</code>。</li></ul></li><li><p>按需加载</p><ul><li>服务器只在接受到 import 请求的时候，才会编译对应的文件，将 ESM 源码返回给浏览器，实现真正的按需加载。</li></ul></li><li><p>缓存</p><ul><li>HTTP缓存： 充分利用 http 缓存做优化，依赖（不会变动的代码）部分用<code>max-age, immutable强缓存</code>，源码部分用<code> 304 协商缓存</code>，提升页面打开速度。</li><li>文件系统缓存： Vite 在预构建阶段，将构建后的依赖<code>缓存</code>到 <code>node_modules/.vite</code> ，相关配置更改时，或手动控制时才会重新构建，以提升预构建速度。</li></ul></li><li><p>重写模块路径</p><ul><li>浏览器 import 只能引入相对/绝对路径，而开发代码经常使用 npm 包名直接引入 node_module 中的模块，需要做路径转换后交给浏览器。</li><li>es-module-lexer 扫描 import 语法</li><li>magic-string 重写模块的引入路径</li></ul></li></ul><p>优势：</p><ul><li>非常快</li><li>高度集成，开箱即用</li><li>基于 ESM 急速热更新，无需打包编译</li><li>基于 esbuild 的依赖预处理，比 Webpack 等 node 编写的编译器快几个数量级</li><li>兼容 Rollup 庞大的插件机制，插件开发更简洁</li><li>不与 Vue 绑定，支持 React 等其他框架，独立的构建工具</li><li>内置 SSR 支持</li><li>天然支持TS</li></ul><p>不足：</p><ul><li>Vue 仍为第一优先支持，量身定做的编译插件，对 React 的支持不如 Vue 强大。</li><li>虽然已经推出2.0正式版，已经可以用于正式线上生产，但目前市场上实践少。</li><li>生产环境集成 <code>Rollup</code> 打包，<code>与开发环境最终执行的代码不一致</code>。</li></ul><p>官方插件：</p><ul><li>@vitejs/plugin-vue 提供 Vue3 单文件组件支持</li><li>@vitejs/plugin-vue-jsx 提供 Vue3 JSX 支持（专用的 Babel 转换插件）</li><li>@vitejs/plugin-react 提供完整的 React 支持</li><li>@vitejs/plugin-legacy 为打包后的文件提供传统浏览器兼容性支持</li></ul></details><details class="details custom-block"><summary>相比于npm和yarn，pnpm的优势是什么？</summary><p>pnpm对比npm/yarn的优点：</p><ul><li>更快速的依赖下载</li><li>更高效的利用磁盘空间</li><li>更优秀的依赖管理</li></ul><p>软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。</p></details><details class="details custom-block"><summary>AST 语法树是什么？</summary><p>AST是<code>抽象语法树</code>（Abstract Syntax Tree）的缩写，它是一种用于表示程序源代码结构的<code>树状数据结构</code>。AST 可以将源代码解析为一个由节点组成的树形结构，每个节点代表着代码中的一个特定语法结构或语义概念。</p><p>以下是常见的使用情况：</p><ul><li><code>解析和验证</code>：通过解析源代码，将其转换为 AST 之后，可以对代码进行<code>验证</code>和<code>静态分析</code>。这包括检查语法错误、类型错误、变量引用等，并发现潜在的问题或优化机会。</li><li><code>优化和转换</code>：AST 可以用于执行各种<code>优化操作</code>，例如消除冗余代码、提取共享表达式、内联函数调用等。它还能够进行代码转换，例如将ES6代码转换为ES5兼容的代码、将模板编译为渲染函数等。</li><li><code>生成代码</code>：从 AST 中可以再次生成目标代码，如JavaScript、HTML、CSS等。这使得可以将源代码翻译为其他语言、在不同平台上执行代码等。</li></ul><p>通过使用AST，开发人员可以更好地理解和分析代码的结构，从而进行<code>静态分析</code>、<code>优化</code>和<code>转换</code>等操作。它也为很多编程工具提供了基础，如编译器、静态代码分析工具和IDE等。</p></details><details class="details custom-block"><summary>微前端中的应用隔离是什么，一般是怎么实现的？</summary><ul><li>技术栈无关: 主框架不限制接入应用的技术栈，微应用具备完全自主权</li><li>独立开发、独立部署: 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li><li>增量升级: 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</li><li>独立运行时: 每个微应用之间状态隔离，运行时状态不共享</li></ul><p>CSS隔离:</p><ul><li>当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离 CSS 污染，可以采用<code>CSS Module</code>或者<code>命名空间</code>的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用 webpack 的 postcss 插件，在打包时添加特定的前缀。</li><li>而对于微应用与微应用之间的 CSS 隔离就非常简单，在每次应用加载时，将该应用所有的 link 和 style 内容进行标记。在应用卸载后，同步卸载页面上对应的 link 和 style 即可。</li></ul><p>JavaScript隔离:</p><ul><li>采用沙箱机制（<code>SandBox</code>）。沙箱机制的核心是让局部的 JavaScript 运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在 Node.js 端可以采用 <code>vm</code> 模块，而对于浏览器，则需要结合 <code>with</code> 关键字和 <code>window.Proxy</code> 对象来实现浏览器端的沙箱</li></ul></details><details class="details custom-block"><summary>RESTful 接口规范是什么 ？</summary><p>RESTful 接口规范是一种设计 Web 服务接口的风格和规范，遵循 REST（Representational State Transfer）架构。它的设计原则包括以下几点：</p><ul><li><p>资源（Resources）：将系统中的所有事物视为资源，每个资源都有一个唯一的标识符（通常是 URL），用于对其进行操作。</p></li><li><p>统一接口（Uniform Interface）：接口设计应该简单一致，包括以下几个方面：</p><ul><li>使用标准的 HTTP 方法（GET、POST、PUT、DELETE 等）来对资源进行操作。</li><li>使用标准的 HTTP 状态码（如 200、404、500）来表示请求结果。</li><li>使用资源的 URL 来唯一标识资源。</li><li>使用适当的 MIME 类型（如 JSON、XML）来传输数据。</li></ul></li><li><p>状态无关（Stateless）：每个请求都应该包含足够的信息，服务器不需要保存客户端的状态。这样可以使系统更加简单、可伸缩性更好。</p></li><li><p>客户端 - 服务器分离（Client-Server Separation）：客户端和服务器之间的交互应该通过标准化的接口进行，使得客户端和服务器可以独立地进行演化。</p></li><li><p>可缓存性（Cacheability）：对于经常不变的数据，应该使用合适的缓存机制，提高系统的性能和可伸缩性。</p></li><li><p>按需代码（Code on Demand）（可选）：服务器可以向客户端传输可执行代码，以提供更丰富的功能。</p></li></ul><p>遵循 RESTful 接口规范能够使得系统具有良好的可维护性、可伸缩性和性能，并且更容易与其他系统进行集成。</p></details><details class="details custom-block"><summary>大文件断点续传 ？</summary><ul><li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li><li>初始化一个分片上传任务，返回本次分片上传<code>唯一标识</code>；</li><li>按照一定的<code>策略</code>（串行或并行）发送各个分片数据块；</li><li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块<code>合并</code>成得到原始文件</li></ul></details><details class="details custom-block"><summary>JSBridge是什么？</summary><p>JSBridge的原理主要基于<code>双向通信的通道机制</code>，它连接了 Native（原生代码）和H5（HTML5），使得两者能够<code>互相调用对方的功能</code>。具体来说，JSBridge通过在原生代码中<code>嵌入JavaScript引擎</code>，以及在JavaScript环境中提供对<code>原生代码的访问接口</code>，实现了两者之间的通信。</p><p>JSBridge是给 JavaScript 提供调用 <code>Native</code> 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能（例如：地址位置、摄像头）。</p><p>实际上，JSBridge 就像其名称中的 Bridge 的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间<code>消息通信</code>的通道，而且这个通信的通道是双向的。</p></details><details class="details custom-block"><summary>什么是单点登录，以及如何进行实现？</summary><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户<code>只需要登录一次</code>就可以访问所有相互信任的应用系统。SSO 一般都需要一个<code>独立的认证中心（passport）</code>，子系统的登录均得通过 passport，子系统本身将不参与登录操作。</p><p>实现：</p><ul><li><p>同域名下的单点登录（<code>cookie 的 domin 属性设置为当前域的父域，并且父域的 cookie 会被子域所共享</code>。Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个 Cookie。）</p></li><li><p>不同域名下的单点登录（可以选择将 Session ID （或 Token ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将 <code>LocalStorage</code> 的数据传递给服务端）</p></li></ul></details><details class="details custom-block"><summary>说一说 loader和 plugin 的区别 ?</summary><p>loader主要用于处理<code>非JavaScript文件</code>，将其转换为<code>webpack能够处理的模块</code>。这包括将各种文件类型（如ES6/ES7、SCSS/Sass/less等）转换为webpack可以理解的JavaScript模块，或者将资源打包成JS文件。loader的作用范围相对较小，它是对每个文件进行单独处理的。例如，babel-loader可以将ES6/ES7代码转换为ES5代码，而css-loader则可以处理CSS文件。loader的使用需要在webpack配置文件的module.rules属性中进行配置，并且需要通过npm安装相应的loader。</p><p>而plugin则是一种用于<code>扩展webpack功能的函数</code>，它可以加入<code>自定义的构建行为</code>，使webpack能够执行更广泛的任务。plugin的功能十分丰富，包括但不限于<code>优化打包结果</code>（如压缩代码、去除无用代码等）、<code>注入环境变量</code>、自动生成页面、生成版本号、引入第三方库、<code>拆分代码</code>以及多页应用打包等。与loader不同，plugin并不直接处理文件内容，而是在webpack构建过程的<code>特定时机执行相应的任务</code>。plugin的使用需要在webpack配置文件的plugins属性中进行配置。</p><p>总的来说，loader和plugin在webpack中各自扮演着重要的角色。<code>loader主要关注文件的转换和处理</code>，使webpack能够处理各种非JavaScript文件；而plugin则主要关注<code>扩展webpack的功能</code>，以满足更复杂的构建需求。两者相互协作，共同构建出高效、灵活的webpack打包方案。</p></details><details class="details custom-block"><summary>webpack 构建流程是怎样的 ?</summary><p>Webpack的构建流程是一个有序且连贯的过程，从初始化配置开始，到最终的输出结束。以下是详细的步骤：</p><ul><li><p>初始化流程：</p><ul><li>从配置文件（如<code>webpack.config.js</code>）和Shell语句中读取与合并参数。</li><li>初始化 <code>compiler</code> 对象，并注册所有配置的插件。</li><li>插件监听 Webpack 构建生命周期的事件节点，做出相应的反应。</li></ul></li><li><p>编译构建流程：</p><ul><li>确定入口：从配置文件指定的 <code>entry</code> 入口开始解析文件，构建 <code>AST</code>（抽象语法树），找出<code>依赖</code>，并开始<code>递归</code>。</li><li>编译模块：在递归过程中，根据文件类型和 <code>loader</code> 配置，调用相应的 loader 对文件进行<code>转换</code>。这包括将各种文件类型（如ES6/ES7、CSS、图片等）转换为 Webpack 能够处理的模块。然后，继续找出该模块依赖的其他模块，并递归执行本步骤，直到所有入口依赖的文件都经过了处理。</li></ul></li><li><p>输出流程：</p><ul><li>对编译后的模块进行组合，生成一个或多个代码块（<code>chunk</code>）。</li><li>将这些 chunk 转换成文件，并输出到文件系统。这通常包括<code>压缩代码</code>、优化输出等操作。</li></ul></li></ul><p>在整个构建流程中，Webpack的插件机制发挥了重要作用。插件可以监听并参与到Webpack构建的各个阶段，从而改变或增强构建行为。这使得Webpack具有高度的灵活性和扩展性，能够应对各种复杂的构建需求。</p></details><details class="details custom-block"><summary>编写 webpack loader 的思路</summary><p>常见的loader:</p><ul><li>样式：<code>style-loader</code>、<code>css-loader</code>、<code>less-loader</code>、sass-loader等</li><li>文件：<code>raw-loader</code>、<code>file-loader</code> 、<code>url-loader</code>等</li><li>编译：<code>babel-loader</code>、<code>ts-loader</code>等</li><li>校验测试：<code>eslint-loader</code>等</li></ul><p>编写一个 webpack loader 的思路主要包括以下几个步骤：</p><ul><li><p>确定需求：</p><ul><li>首先，明确 loader 需要处理哪种类型的文件或数据。例如，你可能想要编写一个处理特定格式文本文件的 loader，或者一个转换图像格式的 loader。</li><li>确定 loader 需要执行的具体转换或操作。</li></ul></li><li><p>安装必要的依赖：</p><ul><li>根据你的 loader 的功能，你可能需要安装一些 npm 包作为依赖项。</li><li>确保这些依赖项在你的 loader 中被正确引用和使用。</li></ul></li><li><p>创建 loader 文件：</p><ul><li>创建一个新的 JavaScript 文件，用于实现你的 loader。</li><li>通常，loader 的名称应该遵循 <code>xxx-loader</code> 的命名规范，其中 <code>xxx</code> 是你的 loader 的名称或功能描述。</li></ul></li><li><p>编写 loader 代码：</p><ul><li>在 loader 文件中，你需要导出一个函数，这个函数将接收源文件内容作为输入。</li><li>在函数内部，执行你需要的转换或操作。这可能包括解析源文件、修改内容、生成新的内容等。</li><li>最后，函数应该返回转换后的内容。</li></ul></li><li><p>处理异步操作：</p><ul><li>如果你的 loader 需要执行异步操作（例如，读取外部文件或发起网络请求），你可以使用异步函数或 Promise。</li><li>确保你的 loader 能够正确处理异步操作，并返回正确的结果。</li></ul></li><li><p>处理错误：</p><ul><li>在 loader 的实现中，要考虑可能出现的错误情况，并相应地处理它们。</li><li>你可以使用 try-catch 语句来捕获和处理错误，或者通过异步函数抛出错误。</li></ul></li><li><p>测试 loader：</p><ul><li>编写测试用例来验证你的 loader 的功能是否正确。</li><li>可以使用 Jest 或其他测试框架来编写测试代码。</li></ul></li><li><p>发布 loader：</p><ul><li>一旦你的 loader 完成并经过测试，你可以将其发布到 npm 上，供其他人使用。</li><li>在发布之前，确保你的 loader 遵循了 webpack 的最佳实践和命名规范。</li></ul></li><li><p>在 webpack 配置中使用 loader：</p><ul><li>在你的 webpack 配置文件中，通过 <code>module.rules</code> 属性来配置你的 loader。</li><li>指定需要应用 loader 的文件类型（通过 <code>test</code> 属性）以及 loader 的名称（通过 <code>use</code> 属性）。</li></ul></li><li><p>调试和优化：</p><ul><li>在实际使用中，可能需要对 loader 进行调试和优化，以确保其性能和稳定性。</li><li>可以使用 webpack 的 <code>--progress</code> 和 <code>--profile</code> 标志来跟踪构建进度和性能瓶颈。</li></ul></li></ul></details><details class="details custom-block"><summary>编写 webpack plugin 的思路</summary><p>编写一个 webpack plugin 的思路主要包括以下几个步骤：</p><ul><li><p>明确需求：</p><ul><li>首先，确定你想要通过插件实现的功能。这可能包括优化构建过程、添加自定义的钩子、处理资源、生成额外的文件等。</li><li>深入理解 webpack 的构建流程和插件机制，以便知道在何时何地插入你的插件逻辑。</li></ul></li><li><p>创建插件文件：</p><ul><li>创建一个新的 JavaScript 文件，用于实现你的插件。</li><li>通常，插件的名称应该遵循 <code>xxx-webpack-plugin</code> 的命名规范，其中 <code>xxx</code> 是你的插件的功能描述。</li></ul></li><li><p>实现 Plugin 类：</p><ul><li>编写一个继承自 <code>webpack.Plugin</code> 的类，并在其中实现你的插件逻辑。</li><li>在构造函数中，可以接收插件的配置参数，并保存为类的实例属性。</li></ul></li><li><p>应用钩子函数：</p><ul><li>webpack 提供了一系列的钩子（hooks），允许插件在构建流程的特定时机插入逻辑。</li><li>在你的 Plugin 类中，通过覆盖 webpack 提供的钩子函数（如 <code>apply</code> 方法），来添加你的自定义逻辑。</li><li>在 <code>apply</code> 方法中，你可以通过 <code>compiler</code> 对象访问 webpack 的编译实例，并监听相应的事件或钩子。</li></ul></li><li><p>处理异步操作：</p><ul><li>如果你的插件需要执行异步操作，确保正确处理异步逻辑。</li><li>可以使用 Promise、async/await 或回调函数来处理异步操作，并确保在适当的时候调用 webpack 提供的回调函数。</li></ul></li><li><p>编写文档和示例：</p><ul><li>为你的插件编写清晰的文档，说明插件的用途、配置选项和使用方法。</li><li>提供示例代码，展示如何在实际项目中使用你的插件。</li></ul></li><li><p>测试插件：</p><ul><li>编写测试用例来验证你的插件的功能是否正确。</li><li>可以使用 Jest 或其他测试框架来编写测试代码，并模拟 webpack 的构建环境。</li></ul></li><li><p>发布插件：</p><ul><li>一旦你的插件完成并经过测试，你可以将其发布到 npm 上，供其他人使用。</li><li>在发布之前，确保你的插件遵循了 webpack 的最佳实践和命名规范。</li></ul></li><li><p>使用插件：</p><ul><li>在你的 webpack 配置文件中，通过 <code>plugins</code> 属性来配置你的插件。</li><li>创建一个插件实例，并将其添加到 <code>plugins</code> 数组中。</li></ul></li><li><p>调试和优化：</p><ul><li>在实际使用中，可能需要对插件进行调试和优化，以确保其性能和稳定性。</li><li>可以使用 webpack 的日志输出和调试工具来跟踪插件的执行情况。</li></ul></li></ul><p>下面是一个简单的 webpack 插件示例代码，这个插件会在 webpack 构建完成后输出一条自定义的消息：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义插件文件：test-webpack-plugin.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;webpack&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestWebpackPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 初始化插件，配置参数options是可选的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在compiler对象上挂载一个webpack事件钩子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.emit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tapAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TestWebpackPlugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compilation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 插件逻辑代码，这里是在构建输出资源到磁盘之前执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TestWebpackPlugin: 正在构建项目...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 模拟异步操作，例如读取文件、网络请求等</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TestWebpackPlugin: 构建完成!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TestWebpackPlugin 输出自定义信息:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.options.message);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 异步操作完成后，调用callback通知webpack</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 也可以监听其他钩子，如done钩子会在构建结束后执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.done.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TestWebpackPluginDoneHook&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stats</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TestWebpackPlugin: 所有构建任务完成!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TestWebpackPlugin;</span></span></code></pre></div><p>要使用这个插件，你需要在你的 <code>webpack.config.js</code> 文件中配置它：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TestWebpackPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./test-webpack-plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引入你的插件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 其他webpack配置 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 实例化插件并传入配置参数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestWebpackPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, Webpack!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>在这个例子中，<code>TestWebpackPlugin</code> 在构建输出资源到磁盘之前（<code>emit</code> 钩子）和构建结束后（<code>done</code> 钩子）各执行了一次。</p><p>请注意，插件可以监听 webpack 提供的各种钩子，并在这些钩子的回调函数中执行自定义逻辑。这个示例中的插件非常简单，只是为了展示如何编写一个基本的 webpack 插件。在实际开发中，插件可能会涉及更复杂的逻辑，比如修改构建输出、处理特定的文件类型、优化资源等。</p></details><details class="details custom-block"><summary>介绍一下 webpack</summary><p>Webpack是一个现代JavaScript应用程序的<code>静态模块打包器（module bundler）</code>，也是目前最为流行的JavaScript打包工具之一。它的主要作用是将项目中的所有模块（包括JavaScript、CSS、图片等）视为一个整体，通过依赖关系将它们打包成一个或多个静态资源文件。</p><p>Webpack的核心特性包括：</p><ul><li><code>模块打包</code>：通过递归检查每个js模块的依赖，<code>构建一个依赖关系图</code>，然后将整个应用程序打包成一个或多个bundle。</li><li><code>依赖管理</code>：能够<code>分析模块之间的依赖关系</code>，根据配置的入口文件找出所有依赖的模块，并将其整合到打包结果中。</li><li><code>文件转换</code>：虽然 Webpack 本身只能处理 JavaScript 模块，但通过加载器（Loader）的使用，可以将其他类型的文件（如CSS、LESS、图片等）转换为有效的模块，使其能够被打包到最终的结果中。</li><li><code>代码拆分</code>：支持将代码拆分成多个模块，按需加载，这有助于实现按需加载和提升应用性能。</li><li><code>插件系统</code>：提供了丰富的插件系统，可以通过插件实现各种功能的扩展，例如压缩代码、自动生成HTML文件等。</li></ul></details><details class="details custom-block"><summary>webpack externals 深入理解</summary><p>如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">externals:{</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  react</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">&#39;React&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  jquery</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">&#39;jQuery&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">我们开发了一个自己的库，里面引用了lodash这个包，经过webpack打包的时候，发现如果把这个lodash包打入进去，打包文件就会非常大。那么我们就可以externals的方式引入。也就是说，自己的库本身不打包这个lodash，需要用户环境提供。</span></span></code></pre></div></details><details class="details custom-block"><summary>项目从 js 迁移到 ts</summary><ul><li>安装 TypeScript*： 在项目的根目录下运行以下命令安装 TypeScript 及其定义文件：<div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> typescript</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tsc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --init</span></span></code></pre></div><code>tsc --init</code> 命令会生成一个 <code>tsconfig.json</code> 文件，这个文件包含了 TypeScript 编译器的配置选项。</li></ul><ol start="2"><li><p>重命名文件： 将 <code>.js</code> 文件重命名为 <code>.ts</code> 文件。TypeScript 编译器可以处理 <code>.ts</code> 文件，并将其编译成 <code>.js</code> 文件。</p></li><li><p>更新 <code>package.json</code>： 确保 <code>package.json</code> 中的 <code>scripts</code> 部分使用 <code>tsc</code> 命令来编译 TypeScript 文件。例如：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;build&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tsc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tsc &amp;&amp; node .&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里的 <code>start</code> 脚本首先编译 TypeScript 文件，然后使用 Node.js 运行编译后的 JavaScript 文件。</p></li><li><p>逐步添加类型注解： 不要一次性为整个项目添加类型注解，这可能会非常耗时且容易出错。相反，你可以从入口文件开始，逐步为函数、变量和类添加类型注解。TypeScript 的类型推断功能可以帮助你自动推断出很多类型，因此你不需要为所有内容都显式地添加类型。</p></li><li><p>使用 TypeScript 的特性： 随着迁移的进行，你可以开始利用 TypeScript 提供的特性，如接口（Interface）、枚举（Enum）、泛型（Generics）等，来改进代码的结构和可维护性。</p></li><li><p>处理第三方库： 如果你的项目依赖了第三方库，并且这些库没有提供 TypeScript 定义文件（<code>.d.ts</code>），你可能需要安装相应的 <code>@types</code> 包或使用其他方法来提供类型信息。例如，通过 <code>npm</code> 安装 <code>@types/库名</code>。</p></li><li><p>运行和测试： 在迁移过程中，不断运行和测试你的应用以确保没有引入新的错误。你可以使用现有的测试套件（如 Jest、Mocha 等）来确保功能没有改变。</p></li><li><p>配置 ESLint： 配置 ESLint 以支持 TypeScript，这有助于在编写代码时捕获潜在问题。你可以使用如 <code>@typescript-eslint/parser</code> 和 <code>@typescript-eslint/eslint-plugin</code> 这样的包来增强 ESLint 对 TypeScript 的支持。</p></li><li><p>持续集成和部署： 更新你的持续集成（CI）和部署流程，以确保新的 TypeScript 代码能够正确编译和部署。</p></li><li><p>文档和代码清理： 随着迁移的完成，更新项目文档以反映新的 TypeScript 实践，并清理任何不再需要的旧 JavaScript 代码或配置。</p></li></ol></details><details class="details custom-block"><summary>taro 的实现原理是怎么样的？</summary><p>Taro 是一个多端统一开发框架，可以使用一套代码编译成微信小程序、支付宝小程序、百度智能小程序、字节跳动小程序、QQ 小程序、快应用、H5 等多个平台的应用。</p><p>Taro 的实现原理主要基于以下几个方面：</p><ul><li><p>JSX 转换：Taro 使用 <code>Babel</code> 插件将类似 HTML 的语法转换为 React 组件。在编译过程中，Taro 还会对 JSX 语法进行优化和压缩，以避免生成不必要的代码。</p></li><li><p>多端适配：Taro 通过<code>封装原生 API </code>和提供不同的 <code>Polyfill</code> 实现多端适配。例如，在微信小程序中，Taro 封装了 <code>wx</code> 对象，使得可以使用类似 React Native 的组件化开发方式；在 H5 中，Taro 则提供了针对浏览器的 Polyfill。</p></li><li><p>跨端样式处理：Taro 通过<code>CSS Modules</code>技术和 <code>PostCSS</code> 插件来处理 CSS 样式。在编译过程中，Taro 会将样式文件转换为 JavaScript 对象，并按需导入到组件中。同时，Taro 提供了 @import 指令或 scss 语法等方式来支持复杂的样式表达。</p></li><li><p>构建系统：Taro 使用 <code>webpack</code> 构建工具来打包编译后的代码，并提供了一系列开箱即用的插件、规则和配置项，例如自动化导入组件、静态资源压缩、TypeScript 支持等。</p></li><li><p>运行时性能优化：Taro 在运行时对代码进行了一些优化，例如使用字典树实现 JSX 解析、避免使用内置事件监听器、减少对原生 API 的调用等方式来优化性能。</p></li></ul><p>Taro 利用 Babel、React、Webpack 等技术，通过封装原生 API 和提供不同的 Polyfill 实现了多端适配，同时也支持复杂的样式表达和自动化导入组件等特性。这些技术的应用使得 Taro 框架在性能、可维护性、跨平台等方面都表现出色。</p><p>Taro 2.x 和 Taro 3 的最大区别可以总结为以下几个方面：</p><ul><li><p>编译方式：Taro 2.x 使用 <code>Gulp</code> 构建工具进行编译，而 Taro 3 改为使用 <code>Webpack</code> 进行构建。这使得 Taro 3 在编译速度、可扩展性、构建配置等方面有了更好的表现。</p></li><li><p>React 版本升级：Taro 2.x 使用的是 React 16 版本，而 Taro 3 升级到了 React 17 版本。React 17 引入了一些新特性，例如以初始渲染器为基础的事件处理、重新设计的事件系统等，从而提高了性能和稳定性。</p></li><li><p>API 改进：Taro 3 对 API 进行了改进，并引入了新的特性。例如，在 JSX 中可以使用 class 关键字来定义 CSS 样式；增加 <code>useReady</code> 钩子函数在小程序生命周期 onReady 被触发时执行；引入了快应用和 H5 等新平台的支持等。</p></li><li><p>插件机制：Taro 3 引入了插件机制，使得开发者可以通过插件实现更多的功能和特性，例如对 <code>TypeScript</code> 支持的扩展、国际化支持等。</p></li><li><p>性能优化：Taro 3 在性能方面进行了优化，例如使用<code>虚拟 DOM </code>进行局部更新，减少对原生 API 的调用等。同时，Taro 3 可以根据平台的不同生成更小的代码包。</p></li></ul><p>Taro 3 引入了一些新特性和优化，并提高了性能、可扩展性和稳定性。</p></details><details class="details custom-block"><summary>提交代码，自动检测并格式化</summary><p>在前端开发中，实现提交代码时自动格式化代码的功能，通常可以通过结合代码编辑器、Git钩子（hooks）以及代码格式化工具来实现。以下是一个基本的实现流程：</p><ul><li>安装代码格式化工具：常用的代码格式化工具有Prettier、ESLint等。这些工具可以根据你的配置规则来格式化代码。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-exact</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prettier</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eslint</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span></span></code></pre></div><ul><li>配置格式化工具：在项目的根目录下创建一个配置文件（如<code>.prettierrc</code>或<code>.eslintrc</code>），并定义你的代码格式化规则。例如，Prettier的配置文件可能如下所示：</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   &quot;singleQuote&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   &quot;semi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   &quot;trailingComma&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;es5&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>对于ESLint，你还需要安装一个格式化插件，比如<code>eslint-plugin-prettier</code>和<code>eslint-config-prettier</code>，以确保ESLint和Prettier能够协同工作。</li></ul><ul><li>使用Git钩子实现提交时自动格式化：如果你想在每次提交代码时自动格式化，你可以使用Git的<code>pre-commit</code>钩子。你可以编写一个脚本，在每次提交前运行格式化工具，并检查是否有文件被修改。如果有文件被修改，你可以提示开发者重新格式化并提交。以下是一个简单的<code>pre-commit</code>钩子示例，使用Prettier自动格式化：</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/sh</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># pre-commit hook to run prettier</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Stash unstaged changes, we don&#39;t want to commit them yet</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --keep-index</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --quiet</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> exit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Run prettier on all staged files</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prettier</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --write</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> diff </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">--cached</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --name-only</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --diff-filter=ACM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;\\.js$&#39;)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Check if prettier made changes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> diff-index</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --quiet</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Prettier found changes, please add them to your commit&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   exit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Restore unstaged changes</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --quiet</span></span></code></pre></div><p>将上述脚本保存为<code>.git/hooks/pre-commit</code>，并确保它有执行权限（<code>chmod +x .git/hooks/pre-commit</code>）。这样，每次尝试提交时，如果Prettier检测到需要格式化的更改，它将自动格式化这些文件，并提示你重新提交。</p></details><details class="details custom-block"><summary>webpack dll ?</summary><p>Webpack DLL（动态链接库）的原理主要基于Webpack的模块化和插件化功能，以及<code>动态链接库（DLL）</code>的概念。它通过将<code>第三方库和代码分离出来，单独打包成一个或多个文件，然后在主项目中引用这些文件，实现代码的复用和优化。</code></p><p>具体来说，Webpack DLL的实现原理包括以下几个方面：</p><ul><li>分离第三方库：Webpack通过 <code>DLLPlugin</code> 插件，将第三方库和代码从主项目中分离出来，单独打包成一个或多个文件。这些文件通常包括库代码本身和库的依赖关系等信息。</li><li>生成映射文件：在打包过程中，Webpack还会生成一个<code>映射文件（通常是JSON格式）</code>，记录库文件和主项目之间的依赖关系。这个文件对于后续的代码引用和加载非常重要。</li><li>引用第三方库：在主项目中，通过 <code>DllReferencePlugin</code> 插件，Webpack将生成的映射文件读入，并根据映射关系将第三方库映射到主项目的相关依赖上。这样，主项目在运行时就可以正确地加载和使用这些库了。</li><li>动态链接和共享：DLL的概念在这里起到了关键作用。动态链接库是一种可以在多个程序之间共享的代码和数据的库。通过Webpack DLL的处理，这些库文件在编译时不会被包含到可执行文件中，而是在运行时被动态加载到内存中。这种方式不仅节省了内存空间，还提高了代码的复用性和灵活性。</li></ul><p>总的来说，Webpack DLL的原理是通过将第三方库和代码分离、打包和映射，实现了代码的复用和优化，提高了应用的性能和可维护性。同时，结合动态链接库的概念，进一步提升了代码的共享和灵活性。</p></details><details class="details custom-block"><summary>single-spa ?</summary><p>Single-spa 是一个用于构建前端微服务架构的 JavaScript 框架，它将多个单页面应用聚合为一个整体应用。以下是关于 Single-spa 的详细介绍：</p><p>single-spa 借鉴了组件<code>生命周期</code>的思想，它为应用设置了针对<code>路由</code>的生命周期。当应用<code>匹配路由</code>/处于激活状态时，应用会把自身的内容挂载到页面上；反之则卸载。典型的 single-spa 由 html 页面、应用注册脚本、应用脚本自身构成。</p><ul><li>应用注册内容包含：</li></ul><ul><li>name 应用名；</li><li>loadingFunction 应用脚本加载函数；</li><li>activityFunction 应用激活态判断函数。</li></ul><ul><li>single-spa 又约定应用脚本包含以下生命周期：</li></ul><ul><li><code>load</code> 当应用匹配路由时就会加载脚本（非函数，只是一种状态）</li><li><code>bootstrap</code> 引导函数（对接 html，应用内容首次挂载到页面前调用）</li><li><code>mount</code> 挂载函数</li><li><code>unmount</code> 卸载函数（须移除事件绑定等内容）</li><li><code>unload</code> 非必要（unload 之后会重新启动 bootstrap 流程；借助 unload 可实现热更新）</li></ul><ul><li>生命周期函数获得参数包含：</li></ul><ul><li>name 应用名</li><li>singleSpa 实例</li><li>mountParcel 手动挂载函数</li><li>customProps 自定义信息；它必须返回 Promise 或其本身为</li><li>async 函数</li></ul><p>优点： Single-spa的优点主要体现在以下几个方面：</p><ul><li>微前端架构支持</li><li>技术栈无关性</li><li>独立部署和升级</li><li>代码共享和复用</li><li>性能优化</li><li>易于扩展</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: string;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  parcels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {},</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NOT_LOADED</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LOADING_SOURCE_CODE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NOT_BOOTSTRAPPED</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BOOTSTRAPPING</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NOT_MOUNTED</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    MOUNTING</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UPDATING</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LOAD_ERROR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MOUNTED</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UNMOUNTING</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SKIP_BECAUSE_BROKEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  customProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { [key: string]: any };</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  loadImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用模块位置或应用脚本加载函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  activeWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boolean;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用激活状态判断函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">customProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mountParcel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">singleSpa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引导函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">customProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mountParcel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">singleSpa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 挂载函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">customProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mountParcel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">singleSpa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 卸载函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  unload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">customProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mountParcel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">singleSpa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 卸载脚本函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  timeouts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { bootstrap, mount, unmount, unload };</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 超时设置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  loadErrorTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  devtools</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { overlays },</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置 window.__SINGLE_SPA_DEVTOOLS__ 的调试环境中使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></details><details class="details custom-block"><summary>GQL</summary><p>GraphQL（Graph Query Language）是一种用于 API 的<code>查询语言</code>，由 <code>Facebook</code> 开发并开源。它允许客户端指定它们想要从服务器获取的确切数据，而不是像传统的 RESTful API 那样，客户端必须从预定义的端点获取数据，并可能收到大量不需要的数据。</p><p>GraphQL 的主要特点包括：</p><ul><li>灵活的数据获取：客户端可以<code>精确</code>地指定它所需要的数据字段，而不是获取整个资源或资源的子集。</li><li>单一端点：与传统的 RESTful API 相比，GraphQL 通常只使用<code>一个端点</code>来处理所有请求。</li><li>类型化：GraphQL 有一个严格的类型系统，这有助于确保数据的完整性和准确性。</li><li>自描述：GraphQL 模式（schema）是自我描述的，客户端可以使用它来理解和查询 API 的能力。</li><li>减少网络往返：由于客户端可以一次请求多个资源或资源的多个字段，因此可以减少网络请求的数量，从而提高性能。</li></ul><p>GraphQL 常用于构建需要高度定制化数据获取的应用程序，特别是那些具有复杂数据模型或需要高度交互性的应用程序。</p><p>在使用 GraphQL 时，你通常会定义一个 <code>schema</code>，它描述了你的数据模型以及可以执行的查询和操作。然后，你可以使用 GraphQL 查询语言来编写查询，这些查询会被发送到服务器，服务器会执行这些查询并返回结果。</p></details><details class="details custom-block"><summary>打包体积优化分析</summary><ul><li>webpack-bundle-analyzer</li></ul></details>`,27),e=[n];function k(t,h,d,r,o,c){return a(),s("div",null,e)}const y=i(p,[["render",k]]);export{g as __pageData,y as default};
