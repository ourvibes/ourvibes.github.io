import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.D3FrRS3M.js";const g=JSON.parse('{"title":"垂直居中","description":"","frontmatter":{},"headers":[],"relativePath":"flow/fe/xiaomi.md","filePath":"flow/fe/xiaomi.md"}'),l={name:"flow/fe/xiaomi.md"},n=e(`<h1 id="垂直居中" tabindex="-1">垂直居中 <a class="header-anchor" href="#垂直居中" aria-label="Permalink to &quot;垂直居中&quot;">​</a></h1><ol><li>display:flex; justify-content: center; align-items: center;</li><li>父类设置 display: flex 子元素设置 margin: auto;</li><li>父元素设置 display: table; text-align: center; 子元素设置 display: table-cell; vertical-align: middle;</li><li>display: grid; place-items: center;</li><li>子元素设置 top: clac( 50% - 元素宽度一半);left: clac( 50% - 元素宽度一半)</li><li>父元素设置 line-height 和 text-align: center 子元素设置行内块元素</li></ol><h1 id="text-align-center-失效" tabindex="-1">text-align: center 失效 <a class="header-anchor" href="#text-align-center-失效" aria-label="Permalink to &quot;text-align: center 失效&quot;">​</a></h1><p>不是块元素 没有设置定宽 设置了浮动属性</p><h1 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h1><p>作用域链的上一层继承this， 指向永远不变 箭头函数不能作为构造函数使用 箭头函数没有arguments 箭头函数没有原型 prototype</p><h1 id="多列布局" tabindex="-1">多列布局 <a class="header-anchor" href="#多列布局" aria-label="Permalink to &quot;多列布局&quot;">​</a></h1><p>column-count column-gap</p><h1 id="state-和-props" tabindex="-1">state 和 props <a class="header-anchor" href="#state-和-props" aria-label="Permalink to &quot;state 和 props&quot;">​</a></h1><ol><li>state 用于组件内部；props 用于组件之间的参数传递；</li><li>state 可变；props 是只读的；</li></ol><h1 id="react-如何传值" tabindex="-1">react 如何传值 <a class="header-anchor" href="#react-如何传值" aria-label="Permalink to &quot;react 如何传值&quot;">​</a></h1><ol><li>props</li><li>Context: createContext(Class) , useContext</li><li>状态管理库 Redux、MobX</li><li>使用路由参数或查询参数</li></ol><h1 id="em-rem" tabindex="-1">em / rem <a class="header-anchor" href="#em-rem" aria-label="Permalink to &quot;em / rem&quot;">​</a></h1><p>em是相对于其父元素的字体大小，而rem是相对于根元素的字体大小</p><h1 id="react中组件之间如何通信" tabindex="-1">React中组件之间如何通信 <a class="header-anchor" href="#react中组件之间如何通信" aria-label="Permalink to &quot;React中组件之间如何通信&quot;">​</a></h1><ol><li>父子组件： props, 回调函数</li><li>兄弟组件: 共用一个父组件</li><li>Message bus</li><li>Context</li><li>状态管理库</li></ol><h1 id="css权重" tabindex="-1">css权重 <a class="header-anchor" href="#css权重" aria-label="Permalink to &quot;css权重&quot;">​</a></h1><p>!important &gt; style &gt; id &gt; 类选择器、属性选择器和伪类(<code>.myClass、[type=&quot;text&quot;]、:hover</code>) &gt; 标签选择器和伪元素(<code>div、p, ::before、::after</code>) &gt; 通配选择器</p><h1 id="flex" tabindex="-1">flex <a class="header-anchor" href="#flex" aria-label="Permalink to &quot;flex&quot;">​</a></h1><p>容器：</p><ul><li>flex-direction、flex-wrap、flex-flow、justify-content（水平）、align-items（垂直）、align-content。</li></ul><p>项目：</p><ul><li>flex-grow、flex-shrink、flex-basic、flex、order、align-self</li></ul><h1 id="less-sass" tabindex="-1">less sass <a class="header-anchor" href="#less-sass" aria-label="Permalink to &quot;less sass&quot;">​</a></h1><p>css预编语言有Sass、Less</p><ul><li>语法不同: <code>Sass</code> 和 <code>Less</code> 使用类似于 <code>CSS</code> 的语法规则</li><li>Sass 使用<code>$</code>符号来定义变量，Less使用<code>@</code>符号</li><li>Sass 和 Less 支持常见的操作符和函数库，例如运算符、颜色处理、字符串处理等</li><li>编译方式不同：Sass 和 Less 都需要通过<code>编译器</code>进行编译，可以将预编译的代码转换成标准的 CSS 代码</li></ul><h1 id="数组方法" tabindex="-1">数组方法 <a class="header-anchor" href="#数组方法" aria-label="Permalink to &quot;数组方法&quot;">​</a></h1><ul><li><code>push()</code>: 在数组末尾添加一个或多个元素，并返回数组的长度。</li><li><code>pop()</code>: 移除并返回数组末尾的元素, 会改变原始数组。</li><li>unshift(): 在数组开头添加一个或多个元素，并返回数组的长度。</li><li>shift(): 移除并返回数组开头的元素，会改变原始数组。</li><li>concat(): 合并两个或更多数组，并返回新的合并后的数组，不会修改原始数组。</li><li>slice(): 从数组中提取指定位置的元素，返回一个新的数组，不会修改原始数组。</li><li><code>splice()</code>: 从指定位置删除或替换元素，可修改原始数组。</li><li>indexOf(): 查找指定元素在数组中的索引，如果不存在则返回-1。</li><li>lastIndexOf(): 从数组末尾开始查找指定元素在数组中的索引，如果不存在则返回-1。</li><li>includes(): 检查数组是否包含指定元素，返回一个布尔值。</li><li>join(): 将数组中的所有元素转为字符串，并使用指定的分隔符连接它们。</li><li><code>reverse()</code>: 颠倒数组中元素的顺序，会修改原始数组。</li><li><code>sort()</code>: 对数组中的元素进行排序，默认按照字母顺序排序，会修改原始数组。</li><li>filter(): 创建一个新数组，其中包含符合条件的所有元素。</li><li>map(): 创建一个新数组，其中包含对原始数组中的每个元素进行操作后的结果。</li><li>reduce(): 将数组中的元素进行累积操作，返回一个单一的值。</li><li>forEach(): 对数组中的每个元素执行提供的函数。</li></ul><h1 id="自定义hooks" tabindex="-1">自定义Hooks <a class="header-anchor" href="#自定义hooks" aria-label="Permalink to &quot;自定义Hooks&quot;">​</a></h1><p>以 use 开头 使用驼峰命名法 准确描述功能 参数以options结尾 返回值符合约定</p><h1 id="怎么控制子组件渲染" tabindex="-1">怎么控制子组件渲染 <a class="header-anchor" href="#怎么控制子组件渲染" aria-label="Permalink to &quot;怎么控制子组件渲染&quot;">​</a></h1><p>shouldComponentUpdate memo</p><h1 id="setstate-更新机制" tabindex="-1">setState 更新机制 <a class="header-anchor" href="#setstate-更新机制" aria-label="Permalink to &quot;setState 更新机制&quot;">​</a></h1><p><a href="https://zhuanlan.zhihu.com/p/275935210" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/275935210</a></p><p>出于性能的考虑，React 可能会把多个 setState 合并成一个调用。</p><p>React 内有个 <code>batchUpdate</code>(批量更新) 的机制，在 React 可以控制的区域 (如组件生命周期、React 封装的事件处理器) 设置标识位 <code>isBatchingUpdate</code> 来决定是否触发更新。</p><p>比如在 React 中注册的 onClick 事件或是 componentDidMount 中直接使用 setState 都是<code>异步</code>的。若想拿到触发更新后的值，可以给 setState 第二个参数传递一个函数，该函数在数据更新后会触发的<code>回调函数</code>，函数的参数就是更新后最新的值。</p><p><code>不受 React 控制</code>的代码快中使用 setState 是<code>同步</code>的，比如在 <code>setTimeout</code> 或是原生的事件监听器 <code>addEventListener</code> 中使用。</p><h1 id="三列布局中间自适应-两边定宽" tabindex="-1">三列布局中间自适应 两边定宽 <a class="header-anchor" href="#三列布局中间自适应-两边定宽" aria-label="Permalink to &quot;三列布局中间自适应 两边定宽&quot;">​</a></h1><p><a href="https://blog.csdn.net/weixin_44867717/article/details/128411368" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_44867717/article/details/128411368</a></p><ol><li>左栏左浮动，右栏右浮动，中间栏用 margin</li><li>container 用 relative, 左右设置 absolute</li><li>container: flex, flex-direction: row; 中间的box使用 flex：1；</li><li>圣杯布局（container设置padding, 左右设置 -margin, 中间box放在最前面）</li><li>双飞翼布局（）</li></ol><h1 id="手写代码题" tabindex="-1">手写代码题 <a class="header-anchor" href="#手写代码题" aria-label="Permalink to &quot;手写代码题&quot;">​</a></h1><p><a href="https://zhuanlan.zhihu.com/p/649951275" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/649951275</a></p><h1 id="手写一个-new" tabindex="-1">手写一个 new <a class="header-anchor" href="#手写一个-new" aria-label="Permalink to &quot;手写一个 new&quot;">​</a></h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //1.创建一个新的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> con</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2.新对象的隐式原型 __proto__ 链接到构造函数的显式原型 prototype</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> con</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 3.构造函数内部的 this 绑定到这个新创建的对象 执行构造函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> con.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 4.如果构造函数没有返回非空对象，则返回创建的新对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h1 id="手写-instanceof" tabindex="-1">手写 instanceof <a class="header-anchor" href="#手写-instanceof" aria-label="Permalink to &quot;手写 instanceof&quot;">​</a></h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取对象的原型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proto </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取构造函数的原型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prototype </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 循环查找原型链</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (proto) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (proto </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prototype) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果找到相同的原型，则返回true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    proto </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proto.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 继续查找上一层原型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果原型链末端都没有找到，则返回false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h1 id="手写-deepclone" tabindex="-1">手写 deepClone <a class="header-anchor" href="#手写-deepclone" aria-label="Permalink to &quot;手写 deepClone&quot;">​</a></h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deepCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasOwnProterty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      newObj[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deepCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newObj;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h1 id="defineproterty-proxy" tabindex="-1">defineProterty proxy <a class="header-anchor" href="#defineproterty-proxy" aria-label="Permalink to &quot;defineProterty  proxy&quot;">​</a></h1><p>Object.defineProperty() 是ES5提供的方法，该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 使用defineProperty只<code>能重定义属性的get和set行为</code>。</p><p>Object.defineProperty(obj, prop, description);</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p>Proxy接收的target<code>可以为任何类型的对象</code>, 可以监听到数据的删除</p><p>new Proxy(target, handler)</p><h1 id="webpack打包流程" tabindex="-1">webpack打包流程 <a class="header-anchor" href="#webpack打包流程" aria-label="Permalink to &quot;webpack打包流程&quot;">​</a></h1><p>初始化配置(entry, output) -&gt; 寻找入口文件 -&gt; 解析依赖 -&gt; 使用对应的 loader 编译 -&gt; 生成一个依赖图 -&gt; 不同的阶段，插件进行相应的处理（代码压缩，环境变量的配置等） -&gt; 输出打包文件(bundle)</p><h1 id="打包优化" tabindex="-1">打包优化 <a class="header-anchor" href="#打包优化" aria-label="Permalink to &quot;打包优化&quot;">​</a></h1><p>按需加载 lazy</p><p>优化文件路径：配置 alias，extensions</p><p>利用IgnorePlugin，避免引入无用模块</p><p>开发环境打开sourceMap，生产环境则关闭</p><p>代码压缩 uglifyJsPlugin</p><p>DllPlugin</p><p>CDN 优化</p>`,65),t=[n];function h(p,k,r,o,d,c){return a(),i("div",null,t)}const y=s(l,[["render",h]]);export{g as __pageData,y as default};
